#!/usr/bin/perl

#
# term-colors - Terminal color palette viewer
#
# Description:
#   Displays all 256 terminal colors in a formatted grid with color codes.
#   Useful for selecting colors for terminal applications and themes.
#
# Usage:
#   term-colors [OPTIONS]
#
# Options:
#   --perl       Show Perl Term::ANSIColor constant names (requires Term::ANSIColor >= 4.0)
#   --both       Show both Perl constant names and ANSI color codes
#   --true|--24  Show 24-bit true color matrix
#
# Examples:
#   term-colors              # Show basic 256 color palette
#   term-colors --perl       # Show Perl constant names
#   term-colors --both       # Show both formats
#   term-colors --true       # Show true color matrix
#
# Dependencies:
#   - Perl 5.x
#   - Term::ANSIColor (optional, for --perl mode)
#
# Originally from:
#   https://github.com/scottchiefbaker/perl-git-prompt/blob/master/utils/term-colors.pl
#

use strict;

my $args   = join(" ",@ARGV);
my ($perl) = $args =~ /--perl/;
my ($both) = $args =~ /--both/;
my ($true) = $args =~ /--(true|24)/;

if ($true) {
	show_true_color_matrix();
}

# If we want both, we set perl also
if ($both) {
	$perl = 1;
}

# Term::ANSIColor didn't get 256 color constants until 4.0
if ($perl && has_term_ansicolor(4.0)) {
	require Term::ANSIColor;
	Term::ANSIColor->import(':constants','color','uncolor');

	#print "TERM::ANSIColor constant names:\n";
	term_ansicolor();
} else {
	my $cols = 120;
	my $rows = 24;
	if (-f '/bin/stty') {
		($rows,$cols) = split(/ /,`/bin/stty size`);
	}

	my $section  = 1;
	my $grouping = 8;

	for (my $i=0;$i<256;$i++) {
		print set_bcolor($i); # Set the background color

		if (needs_white($i)) {
			print set_fcolor(15); # White
			printf("    %03d    ",$i); # Ouput the color number in white
		} else {
			print set_fcolor(0); # Black
			printf("    %03d    ",$i); # Ouput the color number in black
		}

		print set_fcolor(); # Reset both colors
		print "  "; # Seperators

		if ($i == 15 || $i == 231) {
			print set_bcolor(); # Reset
			print "\n\n";
			$section  = 0;
			$grouping = 6;
		} elsif ($section > 0 && ($section % $grouping == 0)) {
			print set_bcolor(); # Reset
			print "\n";
		}

		$section++;
	}
}

END {
	print set_fcolor(); # Reset the colors
	print "\n";
}

#################################################################################
# Subroutines
#################################################################################

#
# has_term_ansicolor($version)
#
# Checks if Term::ANSIColor module is available with specified version.
#
# Parameters:
#   $version - Minimum required version (default: 4)
#
# Returns:
#   1 if module is available with required version, 0 otherwise
#
sub has_term_ansicolor {
	my $version = shift();
	$version ||= 4;

	eval {
		# Check if we have Term::ANSIColor version 4.0
		require Term::ANSIColor;
		Term::ANSIColor->VERSION($version);
	};

	if ($@) {
		return 0;
	} else {
		return 1;
	}
}

#
# set_fcolor($color)
#
# Returns ANSI escape sequence for setting foreground color.
#
# Parameters:
#   $color - Color number (0-255), or undef to reset
#
# Returns:
#   ANSI escape sequence string
#
sub set_fcolor {
	my $c = shift();

	my $ret = '';
	if (!defined($c)) { $ret = "\e[0m"; } # Reset the color
	else { $ret = "\e[38;5;${c}m"; }

	return $ret;
}

#
# set_bcolor($color)
#
# Returns ANSI escape sequence for setting background color.
#
# Parameters:
#   $color - Color number (0-255), or undef to reset
#
# Returns:
#   ANSI escape sequence string
#
sub set_bcolor {
	my $c = shift();

	my $ret = '';
	if (!defined($c)) { $ret = "\e[0m"; } # Reset the color
	else { $ret .= "\e[48;5;${c}m"; }

	return $ret;
}

#
# highlight_string($needle, $haystack, $color)
#
# Highlights a substring within a string using terminal colors.
#
# Parameters:
#   $needle   - String to highlight
#   $haystack - String to search in
#   $color    - Color number to use for highlighting (default: 2 - green)
#
# Returns:
#   String with highlighted needle
#
sub highlight_string {
	my $needle = shift();
	my $haystack = shift();
	my $color = shift() || 2; # Green if they don't pass in a color

	my $fc = set_fcolor($color);
	my $reset = set_fcolor();

	$haystack =~ s/$needle/$fc.$needle.$reset/e;

	return $haystack;
}

#
# get_color_mapping()
#
# Creates a mapping of Term::ANSIColor constant names to color numbers.
#
# Returns:
#   Hash reference mapping color names to numbers (0-255)
#
sub get_color_mapping {
	my $map = {};

	for (my $i = 0; $i < 256; $i++) {
		my $str = "\e[38;5;${i}m";
		my ($acc) = uncolor($str);

		$map->{$acc} = int($i);
	}

	return $map;
}

#
# term_ansicolor()
#
# Displays all 256 colors using Term::ANSIColor constant names.
# Formats output in a grid with optional ANSI number display.
#
sub term_ansicolor {
	my @colors = get_color_names();
	my $map    = get_color_mapping();

	my $absolute = 0;
	my $group    = 0;
	my $grouping = 8;

	print "Showing Term::ANSIColor constant names\n\n";

	foreach my $name (@colors) {
		my $bg          = "on_$name";
		my $map_num     = int($map->{$name});
		my $perl_name   = sprintf("%6s",$name);
		my $ansi_number = sprintf("#%03i",$map_num);

		my $name_string = "";
		if ($both) {
			$name_string = "$perl_name / $ansi_number";
		} else {
			$name_string = "$perl_name";
		}

		if (needs_white($map_num)) {
			print color($bg) . "   " . color('bright_white') . $name_string . "   ";
		} else {
			print color($bg) . "   " . color("black") . $name_string . "   ";
		}
		print color('reset') . "  ";

		$absolute++;
		$group++;

		if ($absolute == 16 || $absolute == 232) {
			print "\n\n";
			$group    = 0;
			$grouping = 6;
		} elsif ($group % $grouping == 0) {
			print "\n";
		}
	}
}

#
# get_color_names()
#
# Generates all 256 Term::ANSIColor constant names.
# Includes ANSI (0-15), RGB (216 colors), and greyscale (24 colors).
#
# Returns:
#   Array of color constant names
#
sub get_color_names {
	my @colors    = ();
	my ($r,$g,$b) = 0;

	for (my $i = 0; $i < 16; $i++) {
		my $name = "ansi$i";
		push(@colors,$name);
	}

	for ($r = 0; $r <= 5; $r++) {
		for ($g = 0; $g <= 5; $g++) {
			for ($b = 0; $b <= 5; $b++) {
				my $name = "rgb$r$g$b";
				push(@colors,$name);
			}
		}
	}

	for (my $i = 0; $i < 24; $i++) {
		my $name = "grey$i";
		push(@colors,$name);
	}

	return @colors;
}

#
# needs_white($color_num)
#
# Determines if a background color needs white foreground text for readability.
#
# Parameters:
#   $color_num - Color number (0-255)
#
# Returns:
#   1 if white foreground needed, 0 if black foreground needed
#
sub needs_white {
	my $num = shift();

	# Hard-coded list of dark background colors that need white foreground
	my @white = qw(0 1 4 5 8 232 233 234 235 236 237 238 239 240 241 242 243 16 17 18
	19 20 21 22 28 52 53 54 55 25 56 57 58 59 60 88 89 90 91 92 93 124 125 29 30 31 26
	27 61 62 64 160 196 161 126 63 94 95 100 101 127 128 129 12 130 131 23 24);

	if (grep(/\b$num\b/,@white)) {
		return 1,
	} else {
		return 0;
	}
}

#
# show_true_color_matrix()
#
# Displays a 24-bit true color matrix (16.7 million colors).
# Shows RGB color combinations in a grid pattern.
#
sub show_true_color_matrix {
	my $step  = 32;
	my $reset = set_bcolor();

	for (my $r = 0; $r <= 255; $r += $step) {
		for (my $g = 0; $g <= 255; $g += $step) {
			for (my $b = 0; $b <= 255; $b += $step) {
				# Use 24-bit color escape sequence
				my $color = "\e[48;2;$r;$g;${b}m";

				print $color . "  ";
			}

		}

		print "$reset\n";
	}

	exit;
}
